function BuildStimList(descripFile, stimList, suffix, randstate)%function BUILDSTIMLIST(DESCRIPFILE, STIMLIST, SUFFIX, RANDSTATE)% generates a Marsha/Maggie stimulus list file (STIMLIST) using the design % specified in DESCRIPFILE. If either DESCRIPFILE or STIMLIST is not  % specified, they are selected interactively; if STIMLIST exists it is% silently overwritten. %% BUILDSTIMLIST(...,SUFFIX) allows the user to specify a string that is% appended to recorded data token names using the syntax %	<TOKNAME>_<SERIAL#>_<SUFFIX>% where SERIAL# is a unique sequential index across all experiment tokens% and SUFFIX should have the form <SUBJ_ID>_<EXP_CODE>. If SUFFIX is empty% no modification is made to TOKNAMEs.%% BUILDSTIMLIST(...,RANDSTATE) specified whether the function uses a fixed% random seed (0) or a unique random seed (-1) or a user specified seed% [1,2^32-1]. %% DESCRIPFILE format:%% SPECIFICATION (Examples follow later):% a line beginning with the "//" sequence is ignored as a comment% a line beginning with DEFBLOCK defines the start of input to BUILDBLOCK,%   which  should be terminated by a line beginning with "ENDDEF"%   BUILDBLOCK is a companion function to BUILDSTIMLIST. Please see the%   help of BuildBlock for details.% DEFBLOCK should be of the form%   DEFBLOCK block_name block repcount randfunc arg1 arg2 arg3 ...%   where%   block_name (string identifier for the block)%   block, repcount and randfunc are arguments to BUILDBLOCK%   block (string appended to token name of each acquisition trial and%          typically describes the condition of the trial. e.g. amc =%          audio, emma and clear condition)%   repcount (number of times each stimulus repeated)%   randfunc (matlab function to be used for randomizing the tokens)%       randfunc should be 'none' if no randomization is required%       (function should accept a vector of indices and returns its%       permutation)%   arg1 .. argN (arguments to DEFBLOCK allowing it to be used as a%       template. arguments are specified inside DEFBLOCK as $1, $2, ...%       $N. One can specify multiple words as a single argument as long as%       they are within double quotes (e.g., "quod erat demonstrandum")%% a line beginning with BLOCK embeds the output of the named blocks as%   created by BUILDBLOCK at the location of the line.% BLOCK should be of the form%   BLOCK b1 b2 ... bn blockrep randfunc%   where%   b1, b2, ... bn are block names as defined by DEFBLOCK statements%   blockrep (number of times each block is repeated)%   randfunc (matlab function to be used for randomizing the tokens)%       randfunc should be 'none' if no randomization is required%       (function should accept a matrix of indices and returns its%       permutation. Each column of the matrix will contain a set of blocks%       and the number of columns is equal to blockrep).%% and finally% a line beginning with REDEFBLOCK redefines an existing block% REDEFBLOCK should be of the form%   REDEFBLOCK oldblockname newblockname args%   where%   oldblockname (an already defined block)%   newblockname (name for the new block)%   args (arguments/parameters for the new block. These must match the%       number and nature of the parameters in the original block%       definition.) % all other lines are written as is to output STIMLIST%% % Example BSL file:%%! TEST.BSL  - sample stimulus list description file%%PAUSE Ready?%trial1 \d1 sample trial w/1 second duration%%! BLOCK A:  2 repetitions of three tokens, randomized%%DEFBLOCK A a 2 randomize%// repeat "heed" 2x for each repetition of the others; its color & duration by argument%#T1 \d@3 @0 \e<ROW=-2><COL=4>Say <TXTCOLOR=@2>@1<TXTCOLOR=000000> for me%heed 2 #T1 heed AF0000 1.5%%// template for remaining tokens:  set color by argument%#T2 @0 \e<ROW=-2><COL=4>Say <TXTCOLOR=@2>@1<TXTCOLOR=000000> for me%hid  #T2 hid 0000AF%head #T2 head 00AF00%ENDDEF%%BLOCK A 1 none%%! BLOCK B:  2 repetitions of three tokens, not randomized%%DEFBLOCK B amn 2 none%#T @0 \e<ROW=-2><COL=4>Say <TXTCOLOR=@2>@1<TXTCOLOR=000000> for me%heed #T heed AF0000%hid  #T hid 0000AF%head #T head 00AF00%ENDDEF%%BLOCK B 1 none%%! BLOCK C:  bundle preceding instructional DUMMY token; reset rep offset%%DEFBLOCK C amn 1 none%#D @0 \e<ROW=2><HCEN>Speak when color changes</HCEN><ROW=-2><TXTCOLOR=@2><HCEN>@1</HCEN><TXTCOLOR=000000>%#T @0 acquisition \e<ROW=-2><TXTCOLOR=@2><HCEN>@1</HCEN><TXTCOLOR=000000>%atu #D atu 0000AF #T atu 00AF00%ENDDEF%%BLOCK C 1 none%%! BLOCK PD: practice block%%// Create a block definition that takes one argument%DEFBLOCK PD amn 2 none #D%$1 @0 \e<ROW=-2><COL=4>Say <TXTCOLOR=@2>@1<TXTCOLOR=000000> for me%heed $1 heed AF0000%hid  $1 hid  0000AF%head $1 head 00AF00%ENDDEF%%// Redfines the above block as an actual trial with a random order%REDEFBLOCK PD TD amn 2 randomize #T%%BLOCK PD 1 none%%! BLOCK D: trial block%BLOCK TD 1 none%%! BLOCK S:%%// Create a block definition that takes two arguments%DEFBLOCK S1 amn 2 randomize #T "<BOLD>@1</BOLD> @2"%$1 @0 \e<ROW=-2><COL=4>Say $2 for me%heed $1 heed heed%hid  $1 hid  hid%head $1 head head%ENDDEF%%// Redfines the above block with a different stress pattern%REDEFBLOCK S1 S2 amn 2 randomize #T "@1 <BOLD>@2</BOLD>"%REDEFBLOCK S1 S3 amn 2 randomize #T "@1 @2"% %// Block 1 followed by block 2%BLOCK [S1 S2] 1 none%// Equivalent to %// BLOCK S1 1 none%// BLOCK S2 1 none%%// Repeat each of the 3 blocks 5 times with a randomizer that randomizes%// within each group of three blocks.%BLOCK [S1 S2 S3] 5 blockrandom%% see BUILDBLOCK for further examples and explanation% [3Dec05] Updated help to reflect change of block definition to allow% distinction between filename and prompt% [2Dec05] Updated prompt display to show trial number% satra@speech.mit.edu%	parse argsif nargin < 1,	eval(['help ', which(mfilename)]);	return;end;if isempty(descripFile),	[fn,pn] = uigetfile('*.bsl', 'Select stimulus list description file');	if fn == 0, return; end;	descripFile = fullfile(pn,fn);end;if nargin<2 | isempty(stimList),	[pn,fn] = fileparts(descripFile);	cwd = cd;	if ~isempty(pn), cd(pn); end;		% start search from descripFile location	[fn,pn] = uiputfile([fn,'.lst'], 'Save stimulus list as');	cd(cwd);	if fn == 0, return; end;	stimList = fullfile(pn,fn);end;if nargin<3, suffix = []; end;if nargin<4,    randstate = 25;endif strcmp(stimList,descripFile),    error(sprintf('input and output files are identical'));end%	load descripFiletry,	df = textread(descripFile,'%s','delimiter','\n');catch,	error(sprintf('error attempting to load from %s', descripFile));end;if ~isempty(randstate),    if randstate == -1,        randstate = sum(100*clock);    end    fprintf('randstate[%f]\n',randstate);    rand('state',randstate);end%	parse descriptiondf(strmatch('//',df)) = [];			% kill commentsdef_rows = [];b = strmatch('DEFBLOCK',df);			k = strmatch('ENDDEF',df);nBlocks = length(b);if nBlocks ~= length(k),	error(sprintf('number of DEFBLOCK statements (%d) not matched by number of ENDDEF statements (%d)', ...				nBlocks, length(k)));end;% read defintionsfor b0=1:length(b),    % Parse arguments    % args = regexp(df{b(b0)},'[\w#]*|(".*")','match');    args = regexp(df{b(b0)},'[\w#.<>=/-]*|("((?:[^"\\]|\\.)*)")','match');    if length(args)<5,        error(sprintf('Less than 4 arguments on line: %d\n',b(b0)));    end    BLOCK(b0).name      = args{2};    BLOCK(b0).prefix    = args{3};    BLOCK(b0).tokrep    = str2num(args{4});    BLOCK(b0).randfunc  = args{5};    BLOCK(b0).args      = args(6:end);    BLOCK(b0).offset    = 0;    BLOCK(b0).count     = 0;        % read block    BLOCK(b0).def       = df((b(b0)+1):(k(b0)-1));    def_rows = [def_rows,b(b0):k(b0)];end% create redefined blocksrd = strmatch('REDEFBLOCK',df);			blocklen = length(BLOCK);for rd0=1:length(rd),    % Parse arguments    %args = regexp(df{rd(rd0)},'[\w#]*|(".*")','match');    args = regexp(df{rd(rd0)},'[\w#.<>=/-]*|("((?:[^"\\]|\\.)*)")','match');    if length(args)<6,        error(sprintf('Less than 5 arguments on line: %d\n',rd(rd0)));    end    oldblock = strmatch(args{2},{BLOCK(:).name},'exact');    if isempty(oldblock),        error(sprintf('Undefined block %s on line: %d\n',args{2},rd(rd0)));    end            BLOCK(blocklen+rd0).name      = args{3};    BLOCK(blocklen+rd0).prefix    = args{4};    BLOCK(blocklen+rd0).tokrep    = str2num(args{5});    BLOCK(blocklen+rd0).randfunc  = args{6};    BLOCK(blocklen+rd0).args      = args(7:end);    BLOCK(blocklen+rd0).offset    = 0;    BLOCK(blocklen+rd0).count     = 0;        % read block    BLOCK(blocklen+rd0).def     = BLOCK(oldblock).def;    def_rows = [def_rows,rd(rd0)];end% replace argumentsfor b0=1:length(BLOCK),    for i0=1:length(BLOCK(b0).def),       for a0=1:length(BLOCK(b0).args)           %argval = regexp(BLOCK(b0).args{a0},'[#\w\s<>=]*','match');           argval = regexp(BLOCK(b0).args{a0},'[#\w\s<>=@/.-]*','match');           BLOCK(b0).def{i0} = regexprep(BLOCK(b0).def{i0},sprintf('\\$%d',a0),argval);       end    endend% strip block definitionsdf(def_rows) = [];%	expand blocksb = strmatch('BLOCK',df);df2write = {};lastval = 1;for b0=1:length(b),    % Parse arguments    args = regexp(df{b(b0)},'[\w]*','match');    if length(args)<4,        error(sprintf('Less than 3 arguments on line: %d\n',b(b0)));    end        blockorder{b0} = [];    for a0 = 2:length(args),        blocknum = strmatch(args{a0},{BLOCK(:).name},'exact');        if ~isempty(blocknum)            blockorder{b0} = [blockorder{b0};blocknum];        else,            break        end    end    numrep = str2num(args{a0});    randfunc = args{a0+1};        if numrep>1,        blockorder{b0} = repmat(blockorder{b0},1,numrep);    end    if ~strcmp(lower(randfunc),'none'),        blockorder{b0} = feval(randfunc,blockorder{b0});        %warning('BuildStimList2: randomizing of blocks not implemented yet');    end    blocksize = size(blockorder{b0});    blockorder{b0} = blockorder{b0}(:);    blockdata{b0}  = {};        for i0=1:length(blockorder{b0}),        if mod(i0-1,blocksize(1))==0 & (blocksize(2)>1),            blockdata{b0} = cat(1,blockdata{b0},{sprintf('! Block Rep [%d]\n',floor((i0-1)/blocksize(1))+1)},{' '});        end        blocknum = blockorder{b0}(i0);        if strcmp(lower(BLOCK(blocknum).randfunc),'none'),            randfunc = '';        else            randfunc = BLOCK(blocknum).randfunc;        end        BLOCK(blocknum).count = BLOCK(blocknum).count + 1;        prefix = sprintf('%s_%s_%02d',BLOCK(blocknum).prefix,BLOCK(blocknum).name,BLOCK(blocknum).count);        [BLOCK(blocknum).offset,block] = BuildBlock(...            BLOCK(blocknum).def,...            [],...            prefix,...            BLOCK(blocknum).offset,...            BLOCK(blocknum).tokrep,...            randfunc);        blockdata{b0} = cat(1,blockdata{b0},block,{' '});    end        df2write = cat(1,df2write,df(lastval:(b(b0)-1)),{' '});    df2write = cat(1,df2write,blockdata{b0});    lastval = b(b0)+1;enddf2write = cat(1,df2write,df(lastval:end),{' '});%	write stimListfid = fopen(stimList, 'wt');if fid == -1,	error(sprintf('error attempting to open %s', stimList));end;tokNum = 0;for li = 1 : length(df2write),	s = df2write{li};	if ~isempty(suffix),				% append suffix		[token,stuff] = strtok(s);		if ~(isempty(token) | strcmp(token, 'PAUSE') | strcmp(token, 'DUMMY') | strcmp(token, '!')), 			tokNum = tokNum + 1;            stuff = regexprep(stuff,'\$\$\$',sprintf('%04d',tokNum));			s = sprintf('%s_%04d_%s%s', token, tokNum, suffix, stuff);        else            s = regexprep(s,'\$\$\$','');		end;    else,        s = regexprep(s,'\$\$\$','');	end;	fprintf(fid,'%s\n',s);end;fclose(fid); fprintf('wrote %s\n', stimList);